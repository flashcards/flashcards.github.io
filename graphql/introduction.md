# Introduction | GraphQL Flashcards

<iframe class="FlashcardsIO" src="https://embed.flashcards.io/?url=https://flashcards.github.io/graphql/introduction.html" frameborder="0"></iframe>

### GraphQL
At its simplest, GraphQL is about asking for specific fields on objects. A GraphQL service is created by defining types and fields on those types, then providing functions for each field on each type. GraphQL is a query language for your API, and a server-side runtime for executing queries by using a type system you define for your data.

### Schema Definition Language
The syntax for writing schemas is called Schema Definition Language (SDL). GraphQL has its own type system that’s used to define the *schema* of an API.

### mutation
An operation for creating, modifying and destroying data. When creating one a mutation, you start with the keyword mutation with  the same syntactical structure as queries. Like queries, we’re also able to specify a payload for a mutation in which we can ask for different returned properties.  *Tip: for CRUD mutations to work, you need to provide an ID on the given type.*

### Schema
A schema is a collection of GraphQL types with special root types. It specifies the capabilities of the API and defines how clients can request the data. It is often seen as a *contract* between the server and client.

### Root types
Root types define the entry points for an API. The three root types are Query, Mutation and Subscription.

### types
GraphQL types have unique *IDs* that are generated by the server when new objects are created. The `!`following a type means that the field is *required*.

### field
A unit of data you are asking for in a Schema, which ends up as a field in your JSON response data. Each field can have zero or more arguments if that’s specified in the schema. *Tip: you must add nested subfields until all fields return scalars.*


    type Person {
      name: String!
      age: Int!
    }

The `Person` type has two *fields*, they’re called `name` and `age` and are respectively of type `String` and `Int`. The `!`following the type means that this field is *required*.

### argument
An argument is a set of key-value pairs attached to a specific field. Arguments can be literal values or variables. Some fields require an argument. Mutations require an input object as an argument.


    {
      human(id: "200") {
        weight(unit: "pounds")
        height
      }
    }

`id` is an argument to human in the query above.

### single endpoint
GraphQL APIs typically only expose *a* single endpoint. This works because the structure of the data that’s returned is not fixed. Instead, it’s completely flexible and lets the client decide what data is actually needed.

### query
Every GraphQL service has a `query` type and may or may not have a `mutation` type. These types are a read-only fetch operation to request data from a GraphQL service. They are the same as a regular object type, but they are special because they define the *entry point* of every GraphQL query.

### root field
At the top level of every GraphQL server is a type that represents all of the possible entry points into the GraphQL API, it's often called the *Root* type or the *Query* type.


    {
      allPersons {
        name
      }
    }

The `allPersons` field in this query is called the *root field* of the query. Everything that follows the root field, is called the *payload* of the query.

### subscription
A real-time GraphQL operation. A Subscription is defined in a schema along with queries and mutations. When a client *subscribes* to an event, it will initiate and hold a steady connection to the server. Whenever that particular event then actually happens, the server pushes the corresponding data to the client.


    subscription {
      newPerson {
        name
        age
      }
    }

### Node
Node is a generic term for an object. You can look up a node directly, or you can access related nodes via a connection. If you specify a node that does not return a scalar, you must include subfields until all fields return scalars.

### Edge
Edges represent connections between nodes. When you query a connection, you traverse its edges to get to its nodes. Every `edges` field has a `node` field and a `cursor` field.

### Connection
Connections let you query related objects as part of the same call. With connections, you can use a single GraphQL call where you would have to use multiple calls to a REST API.

### entry points
The `Query`, `Mutation`, and `Subscription` types are the *entry points* for the requests sent by the client.

### GraphiQL
An in-browser IDE for GraphQL development.

## References:
- https://www.apollographql.com/docs/resources/graphql-glossary/
- https://developer.github.com/v4/guides/intro-to-graphql/

